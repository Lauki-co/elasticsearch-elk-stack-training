input {
  file {
    id => "demo-apache-pipeline"
    path => "/Users/sumitsontakke/Downloads/log_files/apache-*.log"
    start_position => "beginning"
    type => "my-apache-fake-logs"
    mode => "tail"
  }
}

filter {
  # Step 1: Try COMMONAPACHELOG
  grok {
    match => { "message" => "%{COMMONAPACHELOG}" }
    tag_on_failure => ["_commonapachefail"]
  }

  # Step 2: Try COMBINEDAPACHELOG if COMMON fails
  if "_commonapachefail" in [tags] {
    grok {
      match => { "message" => "%{COMBINEDAPACHELOG}" }
      tag_on_failure => ["_combinedapachefail"]
    }
  }

  # Step 3: Custom fallback GROK pattern if both failed
  if "_commonapachefail" in [tags] and "_combinedapachefail" in [tags] {
    grok {
      match => {
        "message" => '%{IPORHOST:clientip} %{USER:ident} %{USER:auth} \[%{HTTPDATE:timestamp}\] "%{WORD:verb} %{URIPATHPARAM:request} HTTP/%{NUMBER:httpversion}" %{NUMBER:response} %{NUMBER:bytes}'
      }
      tag_on_failure => ["_customgrokfail"]
    }
  }

  # Step 4: Parse date_time and timezone from timestamp
  if "_customgrokfail" not in [tags] {
    grok {
      match => {
        "timestamp" => "%{DATE_AL:date_time}%{SPACE}%{GREEDYDATA:timezone}"
      }
      pattern_definitions => {
        "DATE_AL" => "%{MONTHDAY}/%{MONTH}/%{YEAR}:%{TIME}"
      }
    }

    date {
      match => [ "timestamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
      target => "@timestamp"
    }
  }

  fingerprint {
    source => ["[user][name]"]
    method => "SHA256"
    key => "any-secret-salt"   # optional for stronger hash
    target => "[user][name_enc]"
  }

}

output {
  elasticsearch {
    hosts => ["https://my-elasticsearch-project-a60faa.es.us-central1.gcp.elastic.cloud:443"]
    api_key => "GfEEhZgBxkEa2s5zdhFF:pl-Z0Qoo2vGxDqu8oyxmDQ"
    ssl_enabled => true
    index => "fakeapache_logs-%{+YYYY.MM.dd}-02"
    manage_template => false
  }
  stdout { codec => rubydebug }
}
